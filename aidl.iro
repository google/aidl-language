name                   = aidl
file_extensions []     = aidl;

################################################################
## Constants
################################################################

__KEYWORD \= (parcelable|cpp_header|const|oneway|enum|union|inout|in|out)
__PRIMITIVE_TYPE \= (void|boolean|byte|char|short|int|long|float|double)
__BUILTIN_TYPE \= (String|CharSequence|List|Map)
__WHITESPACE \= ([ \t\r]+)
__IDENTIFIER \= ([_a-zA-Z][_a-zA-Z0-9]*)
__QUALIFIED_NAME \= ($${__IDENTIFIER}(?:\.$${__IDENTIFIER})+)
__SYMBOL \= ([:;,.=+*/%&|!~<>\^\-]|<<|>>|&&|\|\||<=|>=|==|!=)

################################################################
## Styles
################################################################

styles [] {

.line_comment : style {
   color                 = light_green
   italic                = true
   textmate_scope        = comment.line.double-slash
   pygments_scope        = Comment
}

.block_comment : style {
   color                 = light_green
   italic                = true
   textmate_scope        = comment.block
   pygments_scope        = Comment
}

.doc_comment : style {
   color                 = light_green
   italic                = true
   bold = true
   textmate_scope        = comment.block.documentation
   pygments_scope        = Comment
}

.keyword : style {
   color     = cyan
   textmate_scope        = keyword
   pygments_scope        = Keyword
}

.builtin_type : style {
  color       = yellow
  textmate_scope = support.class
}

.primitive_type : style {
  color       = yellow
  textmate_scope = storage.type
}

.intvalue : style {
   color                 = gold
   textmate_scope        = constant.numeric.decimal
   pygments_scope        = Number
}

.hexvalue : style {
   color                 = green
   textmate_scope        = constant.numeric.hex
   pygments_scope        = Number
}

.floatvalue : style {
   color                 = light_blue
   textmate_scope        = constant.numeric.float
   pygments_scope        = Number
}

.charvalue : style {
   color  = pink
   textmate_scope = constant.character
}

.stringvalue : style {
   color                 = brown
   textmate_scope        = string.quoted.double
   pygments_scope        = String
}

.booleanvalue : style {
   color = blue
   textmate_scope = constant.language
}

.punctuation : style {
   color     = red_2
   textmate_scope        = punctuation
   pygments_scope        = Punctuation
}

.identifier : style {
   color = white
}

.annotation : style {
   color = light_blue
   textmate_scope = storage.type.annotation
}

.illegal : style {
   color                 = white
   background_color      = red
   textmate_scope        = invalid.illegal
   pygments_scope        = Generic.Error
}

.whitespace : style {
   color                = white
}

}

#################################################
## Parse contexts
#################################################

contexts [] {

##############################################
## Main Context - Entry point context
##############################################

main : context {
   : include "multi_line_comment" ;
   
   : pattern {
      regex          \= (//.*)
      styles []       = .line_comment;
   }
   
   : include "package" ;
   : include "import" ;
   : include "decls" ;
   
   : inline_push {
      regex          \= (\{)
      styles []       = .punctuation;
      : pop {
         regex       \= (\})
         styles []    = .punctuation;
      }
      : include "main" ;
   }
   
   : pattern {
      regex          \= ([^\s])
      styles []       = .illegal;
   }
}

package : context {
   : inline_push {
      regex          \= (package)
      styles []       = .keyword;
      : pop {
         regex       \= (;)
         styles []    = .punctuation;
      }
      : pattern {
         regex       \= $${__QUALIFIED_NAME}
         styles []    = .identifier;
      }
   }
}

import : context {
   : inline_push {
      regex          \= (import)
      styles []       = .keyword;
      : pop {
         regex       \= (;)
         styles []    = .punctuation;
      }
      : pattern {
         regex       \= $${__QUALIFIED_NAME}
         styles []    = .identifier;
      }
   }
}

decls : context {
   : include "annotation" ;
   : push {
      regex          \= (interface)(\s+)$${__IDENTIFIER}(\s+)(\{)
      styles []       = .keyword, .whitespace, .identifier, .whitespace, .punctuation;
      context []      = interface_members;
   }
   : push {
      regex          \= (oneway)(\s)(interface)(\s+)$${__IDENTIFIER}(\s+)(\{)
      styles []       = .keyword, .whitespace, .keyword, .whitespace, .identifier, .whitespace, .punctuation;
      context []      = interface_members;
   }
}

interface_members : context {
   : pop {
      regex       \= (\})
      styles []    = .punctuation;
   }
   : include "comments";
   : include "generic" ;
}

comments : context {
   : include "multi_line_comment" ;
   : pattern {
      regex          \= (//.*)
      styles []       = .line_comment;
   }
}

generic : context {
   : include "comments";
   
   : pattern {
      regex          \= (\b$${__KEYWORD}\b)
      styles []       = .keyword;
   }
   
   : pattern {
      regex          \= (\b$${__PRIMITIVE_TYPE}\b)
      styles []       = .primitive_type;
   }
   
   : pattern {
     regex           \= (\b$${__BUILTIN_TYPE}\b)
     styles []        = .builtin_type;
   }
   
   : include "literal" ;
   
   : pattern {
     regex           \= $${__IDENTIFIER}
     styles []        = .identifier;
   }
   
   : inline_push {
      regex          \= (\()
      styles []       = .punctuation;
      : pop {
         regex       \= (\))
         styles []    = .punctuation;
      }
      : include "generic" ;
   }
   
   : inline_push {
      regex          \= (\[)
      styles []       = .punctuation;
      : pop {
         regex       \= (\])
         styles []    = .punctuation;
      }
      : include "generic" ;
   }
   
   : pattern {
      regex          \= $${__SYMBOL}
      styles []       = .punctuation;
   }
}

annotation : context {
   : pattern {
      regex          \= (@$${__IDENTIFIER})
      styles []       = .annotation;
   }
}

literal : context {
   : include "numeric" ;
   : pattern {
      regex          \= ('.')
      styles []      = .charvalue;
   }
   : pattern {
      regex \= ("[^\"]*")
      styles [] = .stringvalue;
   }
   : pattern {
      regex \= (true|false)
      styles [] = .booleanvalue;
   }
}

numeric : context {
   : pattern {
      regex          \= (0[x|X][0-9a-fA-F]+[lL]?)
      styles []       = .hexvalue;
   }
   : pattern {
      // Float must have either a decimal place or an f.
      regex          \= ([0-9]*\.[0-9]+([eE][-+]?[0-9]+)?f?|[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?f)
      styles []       = .floatvalue;
   }
   : pattern {
      regex          \= ([0-9]+[lL]?)
      styles []       = .intvalue;
   }
}

multi_line_comment : context {
   description        = multiline
   : inline_push {
      regex          \= (/\*\*)
      styles []       = .doc_comment;
      default_style   = .doc_comment
      : pop {
         regex       \= (\*/)
         styles []    = .doc_comment;
      }
   }
   : inline_push {
      regex          \= (/\*)
      styles []       = .block_comment;
      default_style   = .block_comment
      : pop {
         regex       \= (\*/)
         styles []    = .block_comment;
      }
   }
}
   
}
